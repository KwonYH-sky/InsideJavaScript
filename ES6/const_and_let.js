// let 키워드는 블록스코프를 가지고 재선언 불가하며 재할당은 가능하다.
var x = 10;
{
    let x = 2;
    // 여기선 x=2
}
//여기선 다시 x=10

// const 키워드 또한 블록스코프를 가지고 있으나 재선언 재할당이 불가능하다.
const a = 1;
a = 2; // Error

/**
 * var와 let의 차이점
 * 
 * var는 블록 스코프가 없다.
 * 즉, if문 or for문 안에서 선언된 var는 전역변수가 되기 때문에 전역 스코프에서 변수를 접근할 수 있다.
 * 함수 안에 있다면 var는 함수 레벨 변수가 되어 함수가 리턴되면 var 변수 또한 사라진다.
 * 
 * var는 변수의 중복 선언을 허용한다.
 * let은 한 스코프 안에서 같은 변수를 두 번 선언하면 에러가 발생한다.
 * 하지만 var로 같은 변수를 여러 번 중복 선언 가능하다.
 * 
 * var는 선언하기 전 사용할 수 있다.
 * var 선언은 함수가 시작 될 때 처리된다. 전역에서 선언된 변수이면 스크립트가 시작 될 때 처리 되고,
 * 함수 본문 내에서 var로 선언된 변수는 선언 위치와 상관없이 함수 본문이 시작되는 지점에서 정의된다. (단, 변수가 중첩 함수 내에서 정의되지 않아야 이 규칙이 적용된다.)
 * 이렇게 변수가 끌어올려지는 현상을 '호이스팅(hoisting)'이라고 부른다.
 * 선언은 호이스팅 되지만 할당은 호이스팅이 되지 않는다.
 * 즉, 변수 선언후 변수에 값을 할당하기 때문에 값이 할당하기 전에 호출시 값이 undefined이 된다.
 */

/**
 * 즉시 실햄 함수 표현식
 * 과거에는 var만 사용 할 수 있었다. var의 스코프는 블록 레벨이 아니기 때문에 var도 블록 레벨을 가질 수 있게 만들 필요가 있었다.
 * 이때 만들어진 것이 '즉시 실행 함수 표현식(immediately-invoked function expressions)'이다.
 * 즉시 실행 함수 표현식은 IIFE라고 부르기도 한다.
 * 즉시 실행 함수 표현식은 요즘에는 자주 쓰지 않는다.
 */